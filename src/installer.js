import { existsSync, mkdirSync, copyFileSync, readFileSync, writeFileSync, appendFileSync } from "node:fs";
import { join, dirname } from "node:path";
import { fileURLToPath } from "node:url";
import { createInterface } from "node:readline";
import { execSync } from "node:child_process";

const __dirname = dirname(fileURLToPath(import.meta.url));
const TEMPLATES = join(__dirname, "..", "templates");

function detectBmadDir(projectRoot) {
  if (existsSync(join(projectRoot, "_bmad"))) return "_bmad";
  if (existsSync(join(projectRoot, ".bmad"))) return ".bmad";
  return null;
}

function readBmadConfig(projectRoot, bmadDir) {
  const configPath = join(projectRoot, bmadDir, "core", "config.yaml");
  if (!existsSync(configPath)) return {};

  const content = readFileSync(configPath, "utf-8");
  const result = {};

  // Simple YAML key extraction (no dependency needed)
  const match = (key) => {
    const re = new RegExp(`^${key}:\\s*["']?(.+?)["']?\\s*$`, "m");
    const m = content.match(re);
    return m ? m[1].replace(/\{project-root\}\/?/, "") : null;
  };

  result.user_name = match("user_name");
  result.output_folder = match("output_folder");

  return result;
}

function getGitUserName() {
  try {
    return execSync("git config user.name", { encoding: "utf-8" }).trim();
  } catch {
    return null;
  }
}

function detect(projectRoot) {
  const bmadDir = detectBmadDir(projectRoot);
  const hasBmad = bmadDir !== null;
  const hasSpeckit = existsSync(join(projectRoot, ".specify"));
  const hasClaudeCommands = existsSync(join(projectRoot, ".claude", "commands"));
  const hasAgreements = existsSync(join(projectRoot, ".agreements"));

  return { hasBmad, bmadDir, hasSpeckit, hasClaudeCommands, hasAgreements };
}

function copyTemplate(src, dest) {
  const destDir = dirname(dest);
  if (!existsSync(destDir)) {
    mkdirSync(destDir, { recursive: true });
  }
  copyFileSync(src, dest);
}

function ask(question) {
  const rl = createInterface({ input: process.stdin, output: process.stdout });
  return new Promise((resolve) => {
    rl.question(question, (answer) => {
      rl.close();
      resolve(answer.trim().toLowerCase());
    });
  });
}

function generateConfig(env, projectRoot) {
  const bmadConfig = env.hasBmad ? readBmadConfig(projectRoot, env.bmadDir) : {};
  const owner = bmadConfig.user_name || getGitUserName() || "";

  // Resolve BMAD artifacts dir
  let bmadArtifactsDir = null;
  if (env.hasBmad && bmadConfig.output_folder) {
    bmadArtifactsDir = bmadConfig.output_folder.replace(/\/$/, "") + "/planning-artifacts";
  } else if (env.hasBmad) {
    bmadArtifactsDir = ".bmad_output/planning-artifacts";
  }

  const lines = [
    `# Agreement System — Project Configuration`,
    `# Generated by: npx agreement-system init`,
    `# Edit this file to customize paths for your project.`,
    ``,
    `version: "1.0.0"`,
    ``,
    `# ── Paths ─────────────────────────────────────────────`,
    `# All paths are relative to project root.`,
    `# Auto-detected at install time. Edit manually if your setup changes.`,
    ``,
    `# BMAD installation directory`,
    `bmad_dir: ${env.hasBmad ? `"${env.bmadDir}"` : "null"}`,
    ``,
    `# BMAD config file`,
    `bmad_config: ${env.hasBmad ? `"${env.bmadDir}/core/config.yaml"` : "null"}`,
    ``,
    `# BMAD planning artifacts output directory`,
    `bmad_artifacts_dir: ${bmadArtifactsDir ? `"${bmadArtifactsDir}"` : "null"}`,
    ``,
    `# Spec Kit installation directory`,
    `speckit_dir: ${env.hasSpeckit ? '".specify"' : "null"}`,
    ``,
    `# Spec Kit specs directory (where feature specs live)`,
    `speckit_specs_dir: "specs"`,
    ``,
    `# ── Defaults ──────────────────────────────────────────`,
    ``,
    `# Default owner for new agreements`,
    `default_owner: "${owner}"`,
    ``,
    `# Breaking change policy applied to all new agreements`,
    `# Options: "agreement-first" | "code-first" | "manual"`,
    `breaking_change_policy: "agreement-first"`,
    ``,
  ];

  return lines.join("\n");
}

export async function install(flags = []) {
  const projectRoot = process.cwd();
  const skipBmad = flags.includes("--skip-bmad");
  const forceBmad = flags.includes("--force-bmad");
  const autoYes = flags.includes("--yes");

  console.log("\n  agreement-system v1.0.0\n");

  // ── Detect environment ──────────────────────────────
  const env = detect(projectRoot);

  console.log("  Environment detected:");
  console.log(`    BMAD:           ${env.hasBmad ? `yes (${env.bmadDir}/)` : "no"}`);
  console.log(`    Spec Kit:       ${env.hasSpeckit ? "yes" : "no"}`);
  console.log(`    Claude commands: ${env.hasClaudeCommands ? "yes" : "no"}`);
  console.log(`    Agreements:     ${env.hasAgreements ? "already installed" : "not found"}`);
  console.log();

  if (env.hasAgreements && !autoYes) {
    const answer = await ask("  .agreements/ already exists. Overwrite templates? (y/N) ");
    if (answer !== "y" && answer !== "yes") {
      console.log("  Skipping core templates (existing agreements preserved).");
      console.log("  Use 'agreement-system update' to update commands only.\n");
      return;
    }
  }

  // ── Step 1: Core ────────────────────────────────────
  console.log("  [1/3] Installing core...");

  const coreMappings = [
    ["core/agreement.tpl.yaml", ".agreements/_templates/agreement.tpl.yaml"],
    ["core/index.yaml", ".agreements/index.yaml"],
    ["core/agreement.md", ".agreements/agreement.md"],
  ];

  for (const [src, dest] of coreMappings) {
    const destPath = join(projectRoot, dest);
    // Don't overwrite index.yaml if it already has agreements
    if (dest === ".agreements/index.yaml" && existsSync(destPath)) {
      const content = readFileSync(destPath, "utf-8");
      if (content.includes("feature_id:")) {
        console.log(`    skip ${dest} (has existing agreements)`);
        continue;
      }
    }
    copyTemplate(join(TEMPLATES, src), destPath);
    console.log(`    write ${dest}`);
  }

  // Generate config with detected paths
  const configPath = join(projectRoot, ".agreements", "config.yaml");
  if (existsSync(configPath)) {
    console.log("    skip .agreements/config.yaml (already configured)");
  } else {
    const configContent = generateConfig(env, projectRoot);
    mkdirSync(dirname(configPath), { recursive: true });
    writeFileSync(configPath, configContent);
    console.log("    write .agreements/config.yaml (paths auto-detected)");
  }

  // ── Step 2: Claude Code commands ────────────────────
  console.log("  [2/3] Installing Claude Code commands...");

  if (!env.hasClaudeCommands) {
    mkdirSync(join(projectRoot, ".claude", "commands"), { recursive: true });
    console.log("    create .claude/commands/");
  }

  const commandMappings = [
    ["commands/agreement.create.md", ".claude/commands/agreement.create.md"],
    ["commands/agreement.sync.md", ".claude/commands/agreement.sync.md"],
    ["commands/agreement.check.md", ".claude/commands/agreement.check.md"],
    ["commands/agreement.doctor.md", ".claude/commands/agreement.doctor.md"],
  ];

  for (const [src, dest] of commandMappings) {
    copyTemplate(join(TEMPLATES, src), join(projectRoot, dest));
    console.log(`    write ${dest}`);
  }

  // ── Step 3: BMAD integration (optional) ─────────────
  const shouldInstallBmad =
    !skipBmad && (forceBmad || env.hasBmad);

  if (shouldInstallBmad) {
    const bmadRoot = env.bmadDir;
    console.log(`  [3/3] Installing BMAD integration (${bmadRoot}/)...`);

    const bmadCustomizeDir = join(projectRoot, bmadRoot, "_config", "agents");
    const bmadMemoryDir = join(projectRoot, bmadRoot, "_memory", "agreements-sidecar");

    if (!existsSync(bmadCustomizeDir)) {
      console.log(`    warn: ${bmadRoot}/_config/agents/ not found, skipping customize.yaml`);
    } else {
      for (const file of ["core-bmad-master.customize.yaml", "bmm-pm.customize.yaml"]) {
        const destPath = join(bmadCustomizeDir, file);
        if (existsSync(destPath)) {
          const content = readFileSync(destPath, "utf-8");
          if (content.includes("agreement")) {
            console.log(`    skip ${file} (already has Agreement integration)`);
            continue;
          }
          // File exists but without our content — append instead of overwrite
          const snippet = readFileSync(join(TEMPLATES, "bmad", file), "utf-8");
          appendFileSync(destPath, "\n" + snippet);
          console.log(`    append ${bmadRoot}/_config/agents/${file}`);
        } else {
          copyTemplate(join(TEMPLATES, "bmad", file), destPath);
          console.log(`    write ${bmadRoot}/_config/agents/${file}`);
        }
      }
    }

    if (!existsSync(bmadMemoryDir)) {
      mkdirSync(bmadMemoryDir, { recursive: true });
    }
    copyTemplate(
      join(TEMPLATES, "bmad", "active-agreements.md"),
      join(bmadMemoryDir, "active-agreements.md")
    );
    console.log(`    write ${bmadRoot}/_memory/agreements-sidecar/active-agreements.md`);
  } else if (env.hasBmad && skipBmad) {
    console.log("  [3/3] BMAD integration skipped (--skip-bmad).");
  } else {
    console.log("  [3/3] No BMAD detected, skipping integration.");
  }

  // ── Done ────────────────────────────────────────────
  console.log();
  console.log("  Done! Agreement System installed.");
  console.log("  Config: .agreements/config.yaml (edit to customize paths)");
  console.log();
  console.log("  Available commands:");
  console.log("    /agreement.create <feature>   Create a new Agreement");
  console.log("    /agreement.sync <feature_id>  Sync with BMAD/Spec Kit artifacts");
  console.log("    /agreement.check <feature_id> Check code drift against Agreement");
  console.log("    /agreement.doctor <feature_id> Generate fix tasks from check FAIL");
  console.log();

  if (env.hasSpeckit) {
    console.log("  Spec Kit detected: /agreement.doctor will generate tasks compatible");
    console.log("  with /speckit.implement.");
    console.log();
  }
}
